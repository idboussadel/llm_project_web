/**
 * Trading Signals Page JavaScript
 * Full pipeline: Multi-source → Sentiment → TFT → Signals
 */

// DOM Elements
const tickerSelect = document.getElementById("tickerSelect");
const generateBtn = document.getElementById("generateBtn");
const loadingState = document.getElementById("loadingState");
const errorState = document.getElementById("errorState");
const errorMessage = document.getElementById("errorMessage");
const emptyState = document.getElementById("emptyState");
const resultsDisplay = document.getElementById("resultsDisplay");

// Enable/disable button based on selection
tickerSelect.addEventListener("change", (e) => {
  generateBtn.disabled = !e.target.value;
});

// Generate signal button
generateBtn.addEventListener("click", async () => {
  const ticker = tickerSelect.value;

  if (!ticker) {
    showError("Please select a ticker");
    return;
  }

  await generateTradingSignal(ticker);
});

// API: Generate trading signal
async function generateTradingSignal(ticker) {
  try {
    showLoading();
    hideError();

    const response = await fetch("/api/signals/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        ticker: ticker,
      }),
    });

    const data = await response.json();

    if (!response.ok || !data.success) {
      throw new Error(data.error || "Failed to generate signal");
    }

    displayResults(data.result);
  } catch (error) {
    console.error("Signal generation error:", error);
    showError(error.message || "Failed to generate trading signal");
    showEmptyState();
  } finally {
    hideLoading();
  }
}

// Display complete results
function displayResults(result) {
  emptyState.classList.add("hidden");
  resultsDisplay.classList.remove("hidden");

  // Display trading signal
  displayTradingSignal(result.trading_signal);

  // Display multi-source sentiments
  displaySourceSentiments(result.sources);

  // Display aggregated sentiment
  displayAggregatedSentiment(result.aggregated_sentiment);

  // Display TFT prediction
  displayTFTPrediction(result.tft_prediction);
}

// Display trading signal
function displayTradingSignal(signal) {
  const signalBadge = document.getElementById("signalBadge");
  const signalConfidence = document.getElementById("signalConfidence");
  const signalReasoning = document.getElementById("signalReasoning");
  const signalCard = document.getElementById("signalCard");

  signalBadge.textContent = signal.action;
  signalConfidence.textContent = `${(signal.confidence * 100).toFixed(1)}%`;
  signalReasoning.textContent = signal.reasoning;

  // Set colors
  signalBadge.className = "px-6 py-3 rounded-md font-bold text-2xl";
  signalCard.className = "border-l-4 pl-4";

  if (signal.color === "bullish") {
    signalBadge.classList.add("bg-positive", "text-white");
    signalCard.classList.add("border-positive");
  } else if (signal.color === "bearish") {
    signalBadge.classList.add("bg-negative", "text-white");
    signalCard.classList.add("border-negative");
  } else {
    signalBadge.classList.add("bg-neutral", "text-white");
    signalCard.classList.add("border-neutral");
  }

  // Re-initialize Lucide icons
  if (typeof lucide !== "undefined") {
    lucide.createIcons();
  }
}

// Show trading signal info modal
function showTradingSignalInfo() {
  const modal = document.getElementById("infoModal");
  const modalTitle = document.getElementById("infoModalTitle");
  const modalContent = document.getElementById("infoModalContent");

  modalTitle.textContent = "Trading Signal";
  modalContent.innerHTML = `
    <div class="space-y-4">
      <p class="text-sm text-foreground leading-relaxed">
        Trading signals are generated by combining sentiment analysis from multiple sources (Earnings Transcripts, News Articles, Social Media) with TFT (Temporal Fusion Transformer) price predictions. The system analyzes both qualitative sentiment and quantitative price forecasts to generate actionable trading recommendations.
      </p>
      <div class="pt-3 border-t border-border space-y-3">
        <div>
          <h4 class="text-xs font-semibold text-foreground mb-2">Signal Types:</h4>
          <div class="space-y-1.5 text-xs text-muted-foreground">
            <div><span class="font-semibold text-foreground">BUY:</span> Positive sentiment and/or predicted price increase</div>
            <div><span class="font-semibold text-foreground">SELL:</span> Negative sentiment and/or predicted price decrease</div>
            <div><span class="font-semibold text-foreground">HOLD:</span> Mixed or neutral signals suggest waiting</div>
          </div>
        </div>
        <div>
          <h4 class="text-xs font-semibold text-foreground mb-2">Decision Rule:</h4>
          <div class="space-y-1.5 text-xs text-muted-foreground">
            <div><span class="font-semibold text-foreground">BUY:</span> (Sentiment > 0.1 OR Return > 3%) AND Return > 1%</div>
            <div><span class="font-semibold text-foreground">SELL:</span> (Sentiment < -0.1 OR Return < -3%) AND Return < -1%</div>
            <div><span class="font-semibold text-foreground">HOLD:</span> Otherwise</div>
          </div>
        </div>
      </div>
    </div>
  `;

  modal.classList.remove("hidden");
  
  // Re-initialize Lucide icons
  if (typeof lucide !== "undefined") {
    lucide.createIcons();
  }
}

// Display multi-source sentiments
function displaySourceSentiments(sources) {
  const container = document.getElementById("sourceSentiments");
  container.innerHTML = "";

  const sourceIcons = {
    news: '<i data-lucide="newspaper" class="w-4 h-4"></i>',
    social: '<i data-lucide="message-circle" class="w-4 h-4"></i>',
    earnings: '<i data-lucide="bar-chart-3" class="w-4 h-4"></i>',
  };

  const sourceNames = {
    news: "News Articles",
    social: "Social Media",
    earnings: "Earnings Transcripts",
  };

  for (const [sourceName, data] of Object.entries(sources)) {
    const card = document.createElement("div");
    
    const sentiment = data.sentiment || data.dominant_sentiment;
    const sentimentColor =
      sentiment === "positive"
        ? "text-positive"
        : sentiment === "negative"
          ? "text-negative"
          : "text-neutral";
    
    // Determine border color based on sentiment
    const borderColor =
      sentiment === "positive"
        ? "border-positive/30"
        : sentiment === "negative"
          ? "border-negative/30"
          : "border-neutral/30";
    
    // Determine background color based on sentiment
    const bgColor =
      sentiment === "positive"
        ? "bg-positive/5"
        : sentiment === "negative"
          ? "bg-negative/5"
          : "bg-neutral/5";

    const score = data.score || data.average_score;
    const confidence = data.confidence || data.average_confidence;
    const texts = data.texts || [];

    // Make entire card clickable with hover effects
    card.className = `${bgColor} border ${borderColor} rounded-lg p-4 cursor-pointer transition-all duration-200 hover:shadow-md hover:border-opacity-60 hover:scale-[1.02]`;
    card.setAttribute("data-source", sourceName);
    card.setAttribute("data-title", sourceNames[sourceName]);

    card.innerHTML = `
            <div class="flex items-center justify-between mb-3">
                <div class="flex items-center gap-2">
                    <span class="text-lg text-foreground">${sourceIcons[sourceName]}</span>
                    <span class="font-semibold text-sm text-foreground">${sourceNames[sourceName]}</span>
                    <button 
                        class="info-badge-btn ml-1 p-1 rounded-full hover:bg-foreground/10 transition-colors"
                        data-source="${sourceName}"
                        onclick="event.stopPropagation(); showInfoModal('${sourceName}')"
                    >
                        <i data-lucide="info" class="w-3.5 h-3.5 text-muted-foreground"></i>
                    </button>
                </div>
                <span class="text-xs font-bold px-2 py-1 rounded-md ${sentimentColor} bg-current/10">
                    ${sentiment.toUpperCase()}
                </span>
            </div>
            <div class="flex items-center justify-between text-xs">
                <span class="text-foreground/80 font-medium">Score: <span class="font-semibold">${score.toFixed(2)}</span></span>
                <span class="text-foreground/80 font-medium">Confidence: <span class="font-semibold">${(confidence * 100).toFixed(1)}%</span></span>
                <span class="text-primary font-semibold flex items-center gap-1">
                    ${data.count} texts 
                    <i data-lucide="chevron-right" class="w-3 h-3"></i>
                </span>
            </div>
        `;

    container.appendChild(card);

    // Add click event to the entire card
    card.addEventListener("click", (e) => {
      // Prevent event bubbling if clicking on nested elements
      e.stopPropagation();
      showTextModal(sourceName, texts, sourceNames[sourceName]);
    });
  }

  // Re-initialize Lucide icons for dynamically added content
  if (typeof lucide !== "undefined") {
    lucide.createIcons();
  }
}

// Show text modal
function showTextModal(sourceType, texts, title) {
  const modal = document.getElementById("textModal");
  const modalTitle = document.getElementById("modalTitle");
  const modalContent = document.getElementById("modalContent");

  modalTitle.textContent = title;

  // Create content with improved styling
  let content = '<div class="space-y-4">';
  texts.forEach((text, index) => {
    content += `
            <div class="p-5 bg-card border-2 border-border rounded-lg shadow-sm hover:shadow-md hover:border-primary/30 transition-all">
                <div class="text-xs font-bold text-primary mb-3 uppercase tracking-wide">Text ${index + 1}</div>
                <div class="text-foreground text-sm leading-relaxed">${escapeHtml(text)}</div>
            </div>
        `;
  });
  content += "</div>";

  modalContent.innerHTML = content;
  modal.classList.remove("hidden");
  
  // Re-initialize Lucide icons in modal
  if (typeof lucide !== "undefined") {
    lucide.createIcons();
  }
}

// Close text modal
function closeTextModal() {
  const modal = document.getElementById("textModal");
  modal.classList.add("hidden");
}

// Escape HTML
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

// Close modal on background click
document.addEventListener("click", (e) => {
  const textModal = document.getElementById("textModal");
  const infoModal = document.getElementById("infoModal");
  if (e.target === textModal) {
    closeTextModal();
  }
  if (e.target === infoModal) {
    closeInfoModal();
  }
});

// Show info modal for sentiment sources
function showInfoModal(sourceType) {
  const modal = document.getElementById("infoModal");
  const modalTitle = document.getElementById("infoModalTitle");
  const modalContent = document.getElementById("infoModalContent");

  const sourceInfo = {
    earnings: {
      title: "Earnings Transcripts",
      description: "Official earnings call transcripts from company quarterly reports. These provide direct insights from company executives about financial performance, guidance, and strategic direction.",
      source: "Financial Modeling Prep (FMP) API",
      weight: "30% of aggregated sentiment"
    },
    news: {
      title: "News Articles",
      description: "Recent news articles from financial news sources covering company developments, market analysis, and industry trends. Provides broader market context and analyst perspectives.",
      source: "NewsAPI",
      weight: "40% of aggregated sentiment"
    },
    social: {
      title: "Social Media",
      description: "Social media posts and discussions from platforms like Twitter/X, Reddit, and financial forums. Captures retail investor sentiment and real-time market discussions.",
      source: "Finnhub API",
      weight: "30% of aggregated sentiment"
    }
  };

  const info = sourceInfo[sourceType];
  if (!info) return;

  modalTitle.textContent = info.title;
  modalContent.innerHTML = `
    <div class="space-y-4">
      <p class="text-sm text-foreground leading-relaxed">
        ${info.description}
      </p>
      <div class="pt-3 border-t border-border space-y-2">
        <div class="flex items-center justify-between text-xs">
          <span class="text-muted-foreground">Data Source:</span>
          <span class="font-semibold text-foreground">${info.source}</span>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-muted-foreground">Weight:</span>
          <span class="font-semibold text-foreground">${info.weight}</span>
        </div>
      </div>
    </div>
  `;

  modal.classList.remove("hidden");
  
  // Re-initialize Lucide icons
  if (typeof lucide !== "undefined") {
    lucide.createIcons();
  }
}

// Close info modal
function closeInfoModal() {
  const modal = document.getElementById("infoModal");
  modal.classList.add("hidden");
}

// Display aggregated sentiment
function displayAggregatedSentiment(aggregated) {
  const aggSentiment = document.getElementById("aggSentiment");
  const aggScore = document.getElementById("aggScore");

  const sentiment = aggregated.sentiment;
  const sentimentColor =
    sentiment === "positive"
      ? "text-positive"
      : sentiment === "negative"
        ? "text-negative"
        : "text-neutral";

  aggSentiment.textContent =
    sentiment.charAt(0).toUpperCase() + sentiment.slice(1);
  aggSentiment.className = `text-lg font-semibold ${sentimentColor}`;

  aggScore.textContent = `Score: ${aggregated.score.toFixed(3)} | Confidence: ${(aggregated.confidence * 100).toFixed(1)}%`;
}

// Display TFT prediction
function displayTFTPrediction(prediction) {
  const tftReturn = document.getElementById("tftReturn");
  const tftInterval = document.getElementById("tftInterval");

  const returnPct = prediction.predicted_return * 100;
  const returnColor =
    returnPct > 0
      ? "text-positive"
      : returnPct < 0
        ? "text-negative"
        : "text-neutral";
  

  tftReturn.textContent = `${returnPct > 0 ? "+" : ""}${returnPct.toFixed(2)}%`;
  tftReturn.className = `text-lg font-semibold ${returnColor}`;

  const ci = prediction.confidence_interval;
  tftInterval.textContent = `95% CI: [${(ci.lower * 100).toFixed(2)}%, ${(ci.upper * 100).toFixed(2)}%]`;
}

// Display decision rule
function displayDecisionRule() {
  const decisionRule = document.getElementById("decisionRule");
  decisionRule.innerHTML = `
    <div class="space-y-1.5">
      <div><span class="font-semibold text-foreground">BUY:</span> (Sentiment > 0.1 OR Return > 3%) AND Return > 1%</div>
      <div><span class="font-semibold text-foreground">SELL:</span> (Sentiment < -0.1 OR Return < -3%) AND Return < -1%</div>
      <div><span class="font-semibold text-foreground">HOLD:</span> Otherwise</div>
    </div>
  `;
}

// UI State Management
function showLoading() {
  loadingState.classList.remove("hidden");
  generateBtn.disabled = true;
}

function hideLoading() {
  loadingState.classList.add("hidden");
  generateBtn.disabled = !tickerSelect.value;
}

function showError(message) {
  errorMessage.textContent = message;
  errorState.classList.remove("hidden");
}

function hideError() {
  errorState.classList.add("hidden");
}

function showEmptyState() {
  emptyState.classList.remove("hidden");
  resultsDisplay.classList.add("hidden");
}

// Initialize
document.addEventListener("DOMContentLoaded", () => {
  console.log("Trading Signals page initialized");
  generateBtn.disabled = true;
  
  // Initialize modal click-outside-to-close handler
  const textModal = document.getElementById("textModal");
  if (textModal) {
    textModal.addEventListener("click", (e) => {
      if (e.target === textModal) {
        closeTextModal();
      }
    });
  }
});
